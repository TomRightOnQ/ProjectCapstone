// <auto-generated/>
// Auto-generated added to suppress names errors.

namespace UIWidgets
{
	using System;
	using System.Collections.Generic;
	using System.Collections.ObjectModel;
	using UIWidgets.Attributes;
	using UIWidgets.Styles;
	using UnityEngine;
	using UnityEngine.Events;
	using UnityEngine.EventSystems;
	using UnityEngine.Serialization;
	using UnityEngine.UI;

	/// <summary>
	/// ListViewBase.
	/// You can use it for creating custom ListViews.
	/// </summary>
	public abstract partial class ListViewBase : UIBehaviour,
			ISelectHandler, IDeselectHandler,
			ISubmitHandler, ICancelHandler,
			IStylable, IUpgradeable
	{
		/// <summary>
		/// Range selection mode.
		/// </summary>
		public enum RangeSelectionMode
		{
			/// <summary>
			/// Range from the first selected item to the new selected item.
			/// </summary>
			StartFromFirst = 1,

			/// <summary>
			/// Range from the last selected item to new selected item.
			/// </summary>
			StartFromLast = 0,
		}

		/// <summary>
		/// Instances.
		/// Hidden in inspector.
		/// </summary>
		[SerializeField]
		[FormerlySerializedAs("items")]
		protected List<ListViewItem> instances = new List<ListViewItem>();

		/// <summary>
		/// Gets or sets the items.
		/// </summary>
		/// <value>Items.</value>
		protected List<ListViewItem> Items
		{
			get
			{
				return new List<ListViewItem>(instances);
			}

			set
			{
				UpdateComponents(value);
			}
		}

		/// <summary>
		/// The destroy game objects after setting new items.
		/// Hidden in inspector.
		/// </summary>
		[SerializeField]
		public bool DestroyGameObjects = true;

		[SerializeField]
		[FormerlySerializedAs("Multiple")]
		[FormerlySerializedAs("multiple")]
		bool multipleSelect;

		/// <summary>
		/// Allow select multiple items.
		/// </summary>
		public bool MultipleSelect
		{
			get
			{
				return multipleSelect;
			}

			set
			{
				if (!value && selectedIndices.Count > 1)
				{
					var deselect = SelectedIndicesList;
					for (int i = 0; i < deselect.Count - 1; i++)
					{
						Deselect(deselect[i]);
					}
				}

				multipleSelect = value;
			}
		}

		/// <summary>
		/// Allow select multiple items.
		/// </summary>
		[Obsolete("Use MultipleSelect instead.")]
		public bool Multiple
		{
			get
			{
				return MultipleSelect;
			}

			set
			{
				MultipleSelect = value;
			}
		}

		#if UNITY_EDITOR
		/// <summary>
		/// Validate this instance.
		/// </summary>
		protected override void OnValidate()
		{
			base.OnValidate();
			
			ComponentsColoring(true);

			MultipleSelect = multipleSelect;
		}
		#endif

		[SerializeField]
		int selectedIndex = -1;

		/// <summary>
		/// Gets or sets the index of the selected item.
		/// </summary>
		/// <value>The index of the selected.</value>
		public int SelectedIndex
		{
			get
			{
				return selectedIndex;
			}

			set
			{
				if (value == -1)
				{
					if (selectedIndex != -1)
					{
						Deselect(selectedIndex);
					}

					selectedIndex = value;
				}
				else
				{
					Select(value);
				}
			}
		}

		/// <summary>
		/// Selected indices.
		/// </summary>
		[SerializeField]
		[FormerlySerializedAs("selectedIndicies")]
		protected LinkedHashSet<int> selectedIndices = new LinkedHashSet<int>();

		List<int> selectedIndicesList = new List<int>();

		List<int> tempDeselect = new List<int>();

		List<int> tempSelect = new List<int>();

		/// <summary>
		/// Gets or sets indices of the selected items.
		/// </summary>
		/// <value>The selected indices.</value>
		public List<int> SelectedIndices
		{
			get
			{
				return selectedIndices.Items();
			}

			set
			{
				foreach (var index in selectedIndices)
				{
					if (!value.Contains(index))
					{
						tempDeselect.Add(index);
					}
				}

				foreach (var index in value)
				{
					if (!selectedIndices.Contains(index))
					{
						tempSelect.Add(index);
					}
				}

				foreach (var index in tempDeselect)
				{
					Deselect(index);
				}
				tempDeselect.Clear();

				foreach (var index in tempSelect)
				{
					Select(index);
				}
				tempSelect.Clear();
			}
		}

		/// <summary>
		/// Gets or sets indices of the selected items.
		/// </summary>
		/// <value>The selected indices.</value>
		[Obsolete("Use SelectedIndices.")]
		public List<int> SelectedIndicies
		{
			get
			{
				return SelectedIndices;
			}

			set
			{
				SelectedIndices = value;
			}
		}

		/// <summary>
		/// Reusable selected indices list.
		/// </summary>
		protected List<int> SelectedIndicesList
		{
			get
			{
				selectedIndicesList.Clear();
				selectedIndices.GetItems(selectedIndicesList);

				return selectedIndicesList;
			}
		}

		/// <summary>
		/// Range selection mode.
		/// </summary>
		[SerializeField]
		[Tooltip("Which element is the start when selecting a range with the Shift key.")]
		public RangeSelectionMode RangeMode = RangeSelectionMode.StartFromFirst;

		#region Coloring fields

		/// <summary>
		/// Allow items coloring.
		/// </summary>
		[SerializeField]
		protected bool allowColoring = true;

		/// <summary>
		/// Allow items coloring.
		/// </summary>
		public bool AllowColoring
		{
			get
			{
				return allowColoring;
			}

			set
			{
				if (allowColoring != value)
				{
					allowColoring = value;
					ToggleThemeSupport();
					ComponentsColoring(true);
				}
			}
		}


		/// <summary>
		/// Apply style for the table instead of ListView style.
		/// </summary>
		[SerializeField]
		[FormerlySerializedAs("IsTable")]
		[Tooltip("Is ListView will be displayed as a table?\nUsed for correct styles support.")]
		public bool StyleTable;

		/// <summary>
		/// Apply style for the table instead of ListView style.
		/// </summary>
		[Obsolete("Use StyleTable.")]
		public bool IsTable
		{
			get
			{
				return StyleTable;
			}

			set
			{
				StyleTable = value;
			}
		}

		[SerializeField]
		bool coloringStriped = false;

		/// <summary>
		/// Striped background color.
		/// </summary>
		public bool ColoringStriped
		{
			get
			{
				return coloringStriped;
			}

			set
			{
				if (coloringStriped != value)
				{
					coloringStriped = value;
				}
			}
		}

		/// <summary>
		/// Default background color.
		/// </summary>
		[SerializeField]
		protected Color defaultBackgroundColor = Color.white;

		/// <summary>
		/// Default color.
		/// </summary>
		[SerializeField]
		protected Color defaultColor = Color.black;

		/// <summary>
		/// Default background color.
		/// </summary>
		public Color DefaultBackgroundColor
		{
			get
			{
				return defaultBackgroundColor;
			}

			set
			{
				defaultBackgroundColor = value;
				ComponentsColoring(true);
			}
		}

		/// <summary>
		/// Default text color.
		/// </summary>
		public Color DefaultColor
		{
			get
			{
				return defaultColor;
			}

			set
			{
				defaultColor = value;
				ComponentsColoring(true);
			}
		}

		/// <summary>
		/// Highlighted background color.
		/// </summary>
		[SerializeField]
		[FormerlySerializedAs("HighlightedBackgroundColor")]
		protected Color highlightedBackgroundColor = new Color(203, 230, 244, 255);

		/// <summary>
		/// Color of background on pointer over.
		/// </summary>
		public Color HighlightedBackgroundColor
		{
			get
			{
				return highlightedBackgroundColor;
			}

			set
			{
				highlightedBackgroundColor = value;
				ComponentsHighlightedColoring();
			}
		}

		/// <summary>
		/// Color of text on pointer text.
		/// </summary>
		[SerializeField]
		[FormerlySerializedAs("HighlightedColor")]
		protected Color highlightedColor = Color.black;

		/// <summary>
		/// Color of background on pointer over.
		/// </summary>
		public Color HighlightedColor
		{
			get
			{
				return highlightedColor;
			}

			set
			{
				highlightedColor = value;
				ComponentsHighlightedColoring();
			}
		}

		/// <summary>
		/// Selected background color.
		/// </summary>
		[SerializeField]
		protected Color selectedBackgroundColor = new Color(53, 83, 227, 255);

		/// <summary>
		/// Selected color.
		/// </summary>
		[SerializeField]
		protected Color selectedColor = Color.black;

		/// <summary>
		/// Background color of selected item.
		/// </summary>
		public Color SelectedBackgroundColor
		{
			get
			{
				return selectedBackgroundColor;
			}

			set
			{
				selectedBackgroundColor = value;
				ComponentsColoring(true);
			}
		}

		/// <summary>
		/// Text color of selected item.
		/// </summary>
		public Color SelectedColor
		{
			get
			{
				return selectedColor;
			}

			set
			{
				selectedColor = value;
				ComponentsColoring(true);
			}
		}

		/// <summary>
		/// Default background color if index is even and ColoringStriped enabled.
		/// </summary>
		[SerializeField]
		protected Color defaultEvenBackgroundColor = Color.white;

		/// <summary>
		/// Default background color if index is even and ColoringStriped enabled.
		/// </summary>
		public Color DefaultEvenBackgroundColor
		{
			get
			{
				return defaultEvenBackgroundColor;
			}

			set
			{
				defaultEvenBackgroundColor = value;
				ComponentsColoring(true);
			}
		}

		/// <summary>
		/// Default background color if index is odd and ColoringStriped enabled.
		/// </summary>
		[SerializeField]
		protected Color defaultOddBackgroundColor = Color.white;

		/// <summary>
		/// Default background color if index is odd and ColoringStriped enabled.
		/// </summary>
		public Color DefaultOddBackgroundColor
		{
			get
			{
				return defaultOddBackgroundColor;
			}

			set
			{
				defaultOddBackgroundColor = value;
				ComponentsColoring(true);
			}
		}

		/// <summary>
		/// How long a color transition should take.
		/// </summary>
		[SerializeField]
		public float FadeDuration = 0f;
		#endregion

		/// <summary>
		/// List can be looped and items is enough to make looped list.
		/// </summary>
		/// <value><c>true</c> if looped list available; otherwise, <c>false</c>.</value>
		public virtual bool LoopedListAvailable
		{
			get
			{
				return false;
			}
		}

		/// <summary>
		/// Gets the first displayed index.
		/// </summary>
		/// <value>The first displayed index.</value>
		public virtual int DisplayedIndexFirst
		{
			get
			{
				return 0;
			}
		}

		/// <summary>
		/// Gets the last displayed index.
		/// </summary>
		/// <value>The last displayed index.</value>
		public virtual int DisplayedIndexLast
		{
			get
			{
				return instances.Count - 1;
			}
		}

		/// <summary>
		/// Allow navigation.
		/// </summary>
		[SerializeField]
		public bool Navigation = true;

		/// <summary>
		/// OnSelect event.
		/// </summary>
		[SerializeField]
		public ListViewBaseEvent OnSelect = new ListViewBaseEvent();

		/// <summary>
		/// OnDeselect event.
		/// </summary>
		[SerializeField]
		public ListViewBaseEvent OnDeselect = new ListViewBaseEvent();

		/// <summary>
		/// What to do when the object selected.
		/// </summary>
		[DataBindEvent("SelectedItem", "SelectedItems")]
		[SerializeField]
		public ListViewCustomEvent OnSelectObject = new ListViewCustomEvent();

		/// <summary>
		/// What to do when the object deselected.
		/// </summary>
		[DataBindEvent("SelectedItem", "SelectedItems")]
		[SerializeField]
		public ListViewCustomEvent OnDeselectObject = new ListViewCustomEvent();

		/// <summary>
		/// OnSelect internal event.
		/// </summary>
		[SerializeField]
		[HideInInspector]
		protected internal ListViewCustomEvent OnSelectInternal = new ListViewCustomEvent();

		/// <summary>
		/// OnDeselect internal event.
		/// </summary>
		[SerializeField]
		protected internal ListViewCustomEvent OnDeselectInternal = new ListViewCustomEvent();

		/// <summary>
		/// OnSubmit event.
		/// </summary>
		[SerializeField]
		public UnityEvent onSubmit = new UnityEvent();

		/// <summary>
		/// OnCancel event.
		/// </summary>
		[SerializeField]
		public UnityEvent onCancel = new UnityEvent();

		/// <summary>
		/// OnItemSelect event.
		/// </summary>
		[SerializeField]
		[Obsolete("Replaced with ItemsEvents.Select")]
		public UnityEvent onItemSelect = new UnityEvent();

		/// <summary>
		/// onItemCancel event.
		/// </summary>
		[SerializeField]
		[Obsolete("Replaced with ItemsEvents.Cancel")]
		public UnityEvent onItemCancel = new UnityEvent();

		/// <summary>
		/// The container for items objects.
		/// </summary>
		[SerializeField]
		public RectTransform Container;

		/// <summary>
		/// Container.anchoredPosition wrapper.
		/// </summary>
		protected virtual Vector2 ContainerAnchoredPosition
		{
			get
			{
				var pos = Container.anchoredPosition;
				var scale = Container.localScale;

				return new Vector2(pos.x / scale.x, pos.y / scale.y);
			}

			set
			{
				var scale = Container.localScale;
				Container.anchoredPosition = new Vector2(value.x * scale.x, value.y * scale.y);
			}
		}

		/// <summary>
		/// OnFocusIn event.
		/// </summary>
		[SerializeField]
		public ListViewFocusEvent OnFocusIn = new ListViewFocusEvent();

		/// <summary>
		/// OnFocusOut event.
		/// </summary>
		[SerializeField]
		public ListViewFocusEvent OnFocusOut = new ListViewFocusEvent();

		/// <summary>
		/// Callback after UpdateView() call.
		/// </summary>
		[SerializeField]
		public UnityEvent OnUpdateView = new UnityEvent();

		/// <summary>
		/// What to do when the event system send a pointer enter Event.
		/// </summary>
		[SerializeField]
		[Obsolete("Replaced with ItemsEvents.PointerEnter.")]
		public ListViewCustomEvent OnPointerEnterObject = new ListViewCustomEvent();

		/// <summary>
		/// What to do when the event system send a pointer exit Event.
		/// </summary>
		[SerializeField]
		[Obsolete("Replaced with ItemsEvents.PointerExit.")]
		public ListViewCustomEvent OnPointerExitObject = new ListViewCustomEvent();

		/// <summary>
		/// Navigate event.
		/// </summary>
		[SerializeField]
		public ListViewBaseEvent OnNavigate = new ListViewBaseEvent();

		[NonSerialized]
		bool isListViewBaseInited;

		/// <summary>
		/// Determinate if index can be selected.
		/// </summary>
		public Func<int, bool> CanSelect = AlwaysAllow;

		/// <summary>
		/// Determinate if index can be deselected.
		/// </summary>
		public Func<int, bool> CanDeselect = AlwaysAllow;

		/// <summary>
		/// ListViewItem internal events.
		/// Should be used only by ListView, TreeView, Combobox.
		/// </summary>
		[NonSerialized]
		protected internal readonly ListViewItemEvents InstancesEventsInternal = new ListViewItemEvents();

		/// <summary>
		/// ListViewItem internal instances events.
		/// Should be used only by ListView, TreeView, Combobox.
		/// </summary>
		[Obsolete("Renamed to InstancesEventsInternal.")]
		public ListViewItemEvents ItemsEventsInternal
		{
			get
			{
				return InstancesEventsInternal;
			}
		}

		/// <summary>
		/// ListViewItem instances events.
		/// </summary>
		[SerializeField]
		public ListViewItemEvents InstancesEvents = new ListViewItemEvents();

		/// <summary>
		/// ListViewItem events.
		/// </summary>
		[Obsolete("Renamed to InstancesEvents.")]
		public ListViewItemEvents ItemsEvents
		{
			get
			{
				return InstancesEvents;
			}
		}

		[NonSerialized]
		Selectable selectable;

		/// <summary>
		/// Selectable.
		/// </summary>
		protected Selectable Selectable
		{
			get
			{
				if (selectable == null)
				{
					selectable = GetComponent<Selectable>();
				}

				return selectable;
			}
		}

		/// <summary>
		/// Container with disabled instances.
		/// Hidden in inspector.
		/// </summary>
		[SerializeField]
		RectTransform disabledContainer;

		/// <summary>
		/// Container with disabled instances.
		/// </summary>
		public RectTransform DisabledContainer
		{
			get
			{
				return disabledContainer;
			}

			protected set
			{
				disabledContainer = value;
			}
		}

		/// <summary>
		/// Default function to check if index can be selected or deselected.
		/// </summary>
		/// <param name="index">Index.</param>
		/// <returns>true.</returns>
		public static bool AlwaysAllow(int index)
		{
			return true;
		}

		/// <summary>
		/// Start this instance.
		/// </summary>
		public virtual new void Start()
		{
			base.Start();

			Upgrade();
			Init();
		}

		/// <summary>
		/// Init this instance.
		/// </summary>
		public virtual void Init()
		{
			if (isListViewBaseInited)
			{
				return;
			}

			isListViewBaseInited = true;

			Upgrade();

			if ((selectedIndex != -1) && (selectedIndices.Count == 0))
			{
				selectedIndices.Add(selectedIndex);
			}

			selectedIndices.RemoveWhere(NotIsValid);
			if (selectedIndices.Count == 0)
			{
				selectedIndex = -1;
			}

			OnCanvasGroupChanged();

			AddCallbacks();
		}

		#region ComponentsHighlightedColoring

		/// <summary>
		/// Item highlighted by pointer event.
		/// </summary>
		protected ListViewItem CurrentPointerHighlightedItem
		{
			get
			{
				return GetInstance(IndexUnderPointer);
			}
		}

		/// <summary>
		/// Keep item highlight on pointer enter until selected another item.
		/// </summary>
		[SerializeField]
		[Tooltip("Keep item highlight on pointer enter until will be selected another gameobject.")]
		public bool KeepHighlight = true;

		/// <summary>
		/// Prevent two highlighted gameobjects at same time.
		/// First highlighted object on navigation (selected by EventSystem).
		/// Second highlighted object on pointer enter.
		/// </summary>
		[SerializeField]
		[Tooltip("Prevent two highlighted gameobjects at same time.")]
		public bool OnlyOneHighlighted = false;

		/// <summary>
		/// Last highlight source.
		/// </summary>
		[NonSerialized]
		protected HighlightSource LastHighlightSource;

		/// <summary>
		/// Fix items highlights.
		/// </summary>
		[SerializeField]
		[Obsolete("Now always enabled.")]
		public bool FixHighlightItemUnderPointer = true;

		/// <summary>
		/// Highlighted indices.
		/// </summary>
		readonly protected List<int> highlightedIndices = new List<int>(2);

		/// <summary>
		/// Previously highlighted indices.
		/// </summary>
		readonly protected List<int> prevHighlightedIndices = new List<int>(2);

		/// <summary>
		/// Index under pointer.
		/// </summary>
		protected int IndexUnderPointer = -1;

		/// <summary>
		/// Index under navigation.
		/// </summary>
		protected int IndexUnderNavigation = -1;

		/// <summary>
		/// Highlighted indices.
		/// </summary>
		public ReadOnlyCollection<int> HighlightedIndices
		{
			get
			{
				FindHighlightedIndices();

				return highlightedIndices.AsReadOnly();
			}
		}

		/// <summary>
		/// Find highlighted indices.
		/// </summary>
		protected virtual void FindHighlightedIndices()
		{
			prevHighlightedIndices.Clear();
			prevHighlightedIndices.AddRange(highlightedIndices);
			highlightedIndices.Clear();
			IndexUnderNavigation = -1;
			IndexUnderPointer = -1;

			var allow_navigation = !OnlyOneHighlighted || (LastHighlightSource == HighlightSource.Navigation);
			if (allow_navigation && (EventSystem.current != null))
			{
				var item_under_navigation = FindItemInHierarchy(EventSystem.current.currentSelectedGameObject);
				if (item_under_navigation != null)
				{
					IndexUnderNavigation = item_under_navigation.Index;
					highlightedIndices.Add(IndexUnderNavigation);
				}
			}

			var allow_pointer = !OnlyOneHighlighted || (LastHighlightSource == HighlightSource.PointerEnter);
			if (allow_pointer)
			{
				var item_under_pointer = FindItemUnderPointer();
				if (item_under_pointer != null)
				{
					IndexUnderPointer = item_under_pointer.Index;
					if (IndexUnderPointer != IndexUnderNavigation)
					{
						highlightedIndices.Add(IndexUnderPointer);
					}
				}
			}
		}

		/// <summary>
		/// Apply changed highlighted colors.
		/// </summary>
		protected virtual void ComponentsHighlightedColoring()
		{
			if (!isListViewBaseInited)
			{
				return;
			}

			FindHighlightedIndices();

			foreach (var index in prevHighlightedIndices)
			{
				if (highlightedIndices.Contains(index))
				{
					continue;
				}

				var item = GetInstance(index);
				if (item == null)
				{
					continue;
				}

				Coloring(item);

				if (IsSelected(index))
				{
					item.StateSelected();
				}
				else
				{
					item.StateDefault();
				}
			}

			foreach (var index in highlightedIndices)
			{
				var item = GetInstance(index);
				if (item == null)
				{
					continue;
				}

				HighlightColoring(item);

				item.StateHighlighted();
			}
		}

		/// <summary>
		/// Items under pointer.
		/// </summary>
		protected static ItemsUnderPointerFinder ItemsUnderPointer = new ItemsUnderPointerFinder();

		#if UNITY_EDITOR && UNITY_2019_3_OR_NEWER
		[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.SubsystemRegistration)]
		[DomainReload(nameof(ItemsUnderPointer))]
		static void StaticInit()
		{
			ItemsUnderPointer.Reset();
		}
		#endif

		/// <summary>
		/// Find item under pointer.
		/// </summary>
		/// <returns>Item.</returns>
		protected ListViewItem FindItemUnderPointer()
		{
			var id = GetInstanceID();
			foreach (var item in ItemsUnderPointer)
			{
				if ((item.Owner.GetInstanceID() == id) && Items.Contains(item))
				{
					return item;
				}
			}

			return null;
		}

		/// <summary>
		/// Find item in hierarchy.
		/// </summary>
		/// <param name="go">Gameobject.</param>
		/// <returns>Item.</returns>
		protected virtual ListViewItem FindItemInHierarchy(GameObject go)
		{
			if (go == null)
			{
				return null;
			}

			var current_transform = go.transform;
			if (!current_transform.IsChildOf(Container))
			{
				return null;
			}

			var container_id = Container.GetInstanceID();
			while ((current_transform.parent != null) && (current_transform.parent.GetInstanceID() != container_id))
			{
				current_transform = current_transform.parent;
			}

			return (current_transform.parent == null) ? null : current_transform.GetComponent<ListViewItem>();
		}
		#endregion

		/// <summary>
		/// Gets indices of the selected items.
		/// </summary>
		public void GetSelectedIndices(List<int> output)
		{
			selectedIndices.GetItems(output);
		}

		/// <summary>
		/// Determines if item not exists with the specified index.
		/// </summary>
		/// <returns><c>true</c>, if item not exists, <c>false</c> otherwise.</returns>
		/// <param name="index">Index.</param>
		protected bool NotIsValid(int index)
		{
			return !IsValid(index);
		}

		/// <summary>
		/// Is visible item with specified index.
		/// </summary>
		/// <param name="index">Index.</param>
		/// <param name="minVisiblePart">The minimal visible part of the item to consider item visible.</param>
		/// <returns>true if item visible; false otherwise.</returns>
		public virtual bool IsVisible(int index, float minVisiblePart = 0f)
		{
			return false;
		}

		/// <summary>
		/// Is component instance exists for the item with specified index.
		/// </summary>
		/// <returns><c>true</c> if component exists; otherwise, <c>false</c>.</returns>
		/// <param name="index">Index.</param>
		public virtual bool IsItemVisible(int index)
		{
			return false;
		}

		/// <summary>
		/// Determines whether this instance is horizontal. Not implemented for ListViewBase.
		/// </summary>
		/// <returns><c>true</c> if this instance is horizontal; otherwise, <c>false</c>.</returns>
		public virtual bool IsHorizontal()
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Gets the default height of the item. Not implemented for ListViewBase.
		/// </summary>
		/// <returns>The default item height.</returns>
		public virtual float GetDefaultItemHeight()
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Gets the default width of the item. Not implemented for ListViewBase.
		/// </summary>
		/// <returns>The default item width.</returns>
		public virtual float GetDefaultItemWidth()
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Gets the spacing between items. Not implemented for ListViewBase.
		/// </summary>
		/// <returns>The item spacing.</returns>
		public virtual float GetItemSpacing()
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Gets the horizontal spacing between items. Not implemented for ListViewBase.
		/// </summary>
		/// <returns>The item spacing.</returns>
		public virtual float GetItemSpacingX()
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Gets the vertical spacing between items. Not implemented for ListViewBase.
		/// </summary>
		/// <returns>The item spacing.</returns>
		public virtual float GetItemSpacingY()
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Gets the layout margin.
		/// </summary>
		/// <returns>The layout margin.</returns>
		public virtual Vector4 GetLayoutMargin()
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Process the item cancel event.
		/// </summary>
		/// <param name="index">Index.</param>
		/// <param name="instance">Item.</param>
		/// <param name="eventData">Event data.</param>
		protected virtual void OnItemCancel(int index, ListViewItem instance, BaseEventData eventData)
		{
			if (GetComponent<Selectable>() != null)
			{
				SetSelectedGameObject(gameObject);
			}

			#pragma warning disable 0618
			onItemCancel.Invoke();
			#pragma warning restore 0618
		}

		/// <summary>
		/// Adds the callbacks.
		/// </summary>
		void AddCallbacks()
		{
			InstancesEventsInternal.Cancel.AddListener(OnItemCancel);
			InstancesEventsInternal.Move.AddListener(OnItemMove);
			InstancesEventsInternal.Select.AddListener(OnItemSelect);
			InstancesEventsInternal.Deselect.AddListener(OnItemDeselect);

			InstancesEventsInternal.PointerEnter.AddListener(OnItemPointerEnter);
			InstancesEventsInternal.PointerExit.AddListener(OnItemPointerExit);
		}

		/// <summary>
		/// Removes the callbacks.
		/// </summary>
		void RemoveCallbacks()
		{
			InstancesEventsInternal.Cancel.RemoveListener(OnItemCancel);
			InstancesEventsInternal.Move.RemoveListener(OnItemMove);
			InstancesEventsInternal.Select.RemoveListener(OnItemSelect);
			InstancesEventsInternal.Deselect.RemoveListener(OnItemDeselect);

			InstancesEventsInternal.PointerEnter.RemoveListener(OnItemPointerEnter);
			InstancesEventsInternal.PointerExit.RemoveListener(OnItemPointerExit);
		}

		/// <summary>
		/// Is item with specified index highlighted?
		/// </summary>
		/// <param name="index">Index.</param>
		/// <returns>true if item with specified index highlighted; otherwise false.</returns>
		protected virtual bool IsHighlighted(int index)
		{
			return (IndexUnderPointer == index) || (IndexUnderNavigation == index);
		}

		/// <summary>
		/// Process the pointer enter callback event.
		/// </summary>
		/// <param name="index">Index.</param>
		/// <param name="instance">Item instance.</param>
		/// <param name="eventData">Event data.</param>
		protected virtual void OnItemPointerEnter(int index, ListViewItem instance, PointerEventData eventData)
		{
			#pragma warning disable 0618
			OnPointerEnterObject.Invoke(index);
			#pragma warning restore 0618

			var prev_index = IndexUnderPointer;
			IndexUnderPointer = index;
			LastHighlightSource = HighlightSource.PointerEnter;

			SetHighlight(instance, prev_index);

			if (KeepHighlight)
			{
				SetSelectedGameObject(instance);
			}
		}

		/// <summary>
		/// Process the pointer enter callback event.
		/// </summary>
		/// <param name="index">Index.</param>
		/// <param name="instance">Item instance.</param>
		/// <param name="eventData">Event data.</param>
		protected virtual void OnItemPointerExit(int index, ListViewItem instance, PointerEventData eventData)
		{
			#pragma warning disable 0618
			OnPointerExitObject.Invoke(index);
			#pragma warning restore 0618

			IndexUnderPointer = -1;
			CancelHighlight(instance);
		}

		/// <summary>
		/// Process the item select event.
		/// </summary>
		/// <param name="index">Index.</param>
		/// <param name="instance">Item instance.</param>
		/// <param name="eventData">Event data.</param>
		protected virtual void OnItemDeselect(int index, ListViewItem instance, BaseEventData eventData)
		{
			IndexUnderNavigation = -1;
			CancelHighlight(instance);
		}

		/// <summary>
		/// Process the item select event.
		/// </summary>
		/// <param name="index">Index.</param>
		/// <param name="instance">Item instance.</param>
		/// <param name="eventData">Event data.</param>
		protected virtual void OnItemSelect(int index, ListViewItem instance, BaseEventData eventData)
		{
			#pragma warning disable 0618
			onItemSelect.Invoke();
			#pragma warning restore 0618

			var prev_index = IndexUnderNavigation;
			IndexUnderNavigation = instance.Index;
			LastHighlightSource = HighlightSource.Navigation;

			SetHighlight(instance, prev_index);
		}

		/// <summary>
		/// Set instance highlight.
		/// </summary>
		/// <param name="instance">Instance to highlight.</param>
		/// <param name="prevIndex">Index of instance to cancel highlight.</param>
		protected virtual void SetHighlight(ListViewItem instance, int prevIndex)
		{
			if (OnlyOneHighlighted)
			{
				if (LastHighlightSource == HighlightSource.Navigation)
				{
					var index = IndexUnderPointer;
					IndexUnderPointer = -1;
					CancelHighlight(index);
				}
				else if (LastHighlightSource == HighlightSource.PointerEnter)
				{
					var index = IndexUnderNavigation;
					IndexUnderNavigation = -1;
					CancelHighlight(index);
				}
			}

			CancelHighlight(prevIndex);

			if (!IsSelected(instance.Index))
			{
				HighlightColoring(instance);
				instance.StateHighlighted();
			}
		}

		/// <summary>
		/// Cancel highlight.
		/// </summary>
		/// <param name="index">Instance index to cancel highlight.</param>
		protected virtual void CancelHighlight(int index)
		{
			if (!IsValid(index))
			{
				return;
			}

			var instance = GetInstance(index);
			if (instance != null)
			{
				CancelHighlight(instance);
			}
		}

		/// <summary>
		/// Cancel instance highlight.
		/// </summary>
		/// <param name="instance">Instance to cancel highlight.</param>
		protected virtual void CancelHighlight(ListViewItem instance)
		{
			if (!IsSelected(instance.Index) && (IndexUnderPointer != instance.Index))
			{
				DefaultColoring(instance);
				instance.StateDefault();
			}
		}

		/// <summary>
		/// Process the item move event.
		/// </summary>
		/// <param name="index">Index.</param>
		/// <param name="item">Item.</param>
		/// <param name="eventData">Event data.</param>
		protected virtual void OnItemMove(int index, ListViewItem item, AxisEventData eventData)
		{
			if (!Navigation)
			{
				return;
			}

			if (Selectable != null)
			{
				Selectable.OnMove(eventData);
			}
		}

		/// <summary>
		/// Scrolls to item with specified index.
		/// </summary>
		/// <param name="index">Index.</param>
		public virtual void ScrollTo(int index)
		{
		}

		/// <summary>
		/// Add the specified item.
		/// </summary>
		/// <param name="item">Item.</param>
		/// <returns>Index of added item.</returns>
		public virtual int Add(ListViewItem item)
		{
			if (item.transform.parent != Container)
			{
				item.transform.SetParent(Container, false);
			}

			instances.Add(item);
			item.Owner = this;
			item.Index = instances.Count - 1;

			return instances.Count - 1;
		}

		/// <summary>
		/// Clear items of this instance.
		/// </summary>
		public virtual void Clear()
		{
			UpdateComponents(instances);
		}

		/// <summary>
		/// Remove the item with the specified index.
		/// </summary>
		/// <param name="index">Index.</param>
		public abstract void RemoveItemAt(int index);

		/// <summary>
		/// Remove the specified item.
		/// </summary>
		/// <param name="item">Item.</param>
		/// <returns>Index of removed item.</returns>
		protected virtual int Remove(ListViewItem item)
		{
			var index = item.Index;

			var prev_selected_indices = SelectedIndicesList;
			selectedIndices.Clear();
			foreach (var old_index in prev_selected_indices)
			{
				if (old_index != index)
				{
					selectedIndices.Add(old_index > index ? old_index - 1 : old_index);
				}
			}

			if (selectedIndex == index)
			{
				Deselect(index);
				selectedIndex = selectedIndices.Count > 0 ? selectedIndices.Last() : -1;
			}
			else if (selectedIndex > index)
			{
				selectedIndex -= 1;
			}

			instances.Remove(item);
			Free(item);

			return index;
		}

		/// <summary>
		/// Free the specified item.
		/// </summary>
		/// <param name="item">Item.</param>
		void Free(ListViewItem item)
		{
			if (item == null)
			{
				return;
			}

			item.Owner = null;
		}

		/// <summary>
		/// Update items.
		/// </summary>
		public abstract void UpdateItems();

		/// <summary>
		/// Updates the items.
		/// </summary>
		/// <param name="newItems">New items.</param>
		protected virtual void UpdateComponents<TItem>(List<TItem> newItems)
			where TItem : ListViewItem
		{
			for (int i = 0; i < instances.Count; i++)
			{
				if ((instances[i] != null) && (!newItems.Contains(instances[i] as TItem)))
				{
					Free(instances[i]);
				}
			}

			instances.Clear();
			for (int i = 0; i < newItems.Count; i++)
			{
				newItems[i].transform.SetParent(Container, false);
				newItems[i].Owner = this;
				instances.Add(newItems[i]);
			}
		}

		/// <summary>
		/// Determines if item exists with the specified index.
		/// </summary>
		/// <returns><c>true</c> if item exists with the specified index; otherwise, <c>false</c>.</returns>
		/// <param name="index">Index.</param>
		public virtual bool IsValid(int index)
		{
			return (index >= 0) && (index < instances.Count);
		}

		/// <summary>
		/// Gets the instance.
		/// </summary>
		/// <returns>The instance.</returns>
		/// <param name="index">Index.</param>
		[Obsolete("Replaced with GetInstance(index)")]
		protected ListViewItem GetComponent(int index)
		{
			return GetInstance(index);
		}

		/// <summary>
		/// Gets the instance of the item.
		/// </summary>
		/// <returns>The instance of the item.</returns>
		/// <param name="index">Index.</param>
		public ListViewItem GetInstance(int index)
		{
			for (int i = 0; i < instances.Count; i++)
			{
				if (instances[i].Index == index)
				{
					return instances[i];
				}
			}

			return null;
		}

		/// <summary>
		/// Select item by the specified index.
		/// </summary>
		/// <param name="index">Index.</param>
		public void Select(int index)
		{
			Select(index, true);
		}

		/// <summary>
		/// Select item by the specified index.
		/// </summary>
		/// <param name="index">Index.</param>
		/// <param name="raiseEvents">Raise select events?</param>
		public virtual void Select(int index, bool raiseEvents)
		{
			if (index < 0)
			{
				return;
			}

			if (!IsValid(index))
			{
				var message = string.Format("Index must be between 0 and Items.Count ({0}), but {2}, Gameobject {1}.", (instances.Count - 1).ToString(), name, index.ToString());
				throw new IndexOutOfRangeException(message);
			}

			if (IsSelected(index))
			{
				return;
			}

			if (!CanBeSelected(index))
			{
				return;
			}

			if (!MultipleSelect)
			{
				if ((selectedIndex != -1) && (selectedIndex != index))
				{
					Deselect(selectedIndex, raiseEvents);
				}

				selectedIndices.Clear();
			}

			selectedIndices.Add(index);
			selectedIndex = index;

			SelectItem(index);

			InvokeSelect(index, raiseEvents);
		}

		/// <summary>
		/// Determines whether if item with specified index can be selected.
		/// </summary>
		/// <returns><c>true</c> if item with specified index can be selected; otherwise, <c>false</c>.</returns>
		/// <param name="index">Index.</param>
		protected virtual bool CanBeSelected(int index)
		{
			return CanSelect(index);
		}

		/// <summary>
		/// Determines whether if item with specified index can be deselected.
		/// </summary>
		/// <returns><c>true</c> if item with specified index can be deselected; otherwise, <c>false</c>.</returns>
		/// <param name="index">Index.</param>
		protected virtual bool CanBeDeselected(int index)
		{
			return CanDeselect(index);
		}

		/// <summary>
		/// Invokes the select event.
		/// </summary>
		/// <param name="index">Index.</param>
		/// <param name="raiseEvents">Raise select events?</param>
		protected virtual void InvokeSelect(int index, bool raiseEvents)
		{
			if (!IsValid(index))
			{
				Debug.LogWarning(string.Format("Incorrect index: {0}", index.ToString()), this);
				return;
			}

			OnSelectInternal.Invoke(index);

			if (raiseEvents)
			{
				OnSelect.Invoke(index, GetInstance(index));
				OnSelectObject.Invoke(index);
			}
		}

		/// <summary>
		/// Invokes the deselect event.
		/// </summary>
		/// <param name="index">Index.</param>
		/// <param name="raiseEvents">Raise select events?</param>
		protected virtual void InvokeDeselect(int index, bool raiseEvents)
		{
			OnDeselectInternal.Invoke(index);

			if (raiseEvents)
			{
				OnDeselect.Invoke(index, GetInstance(index));
				OnDeselectObject.Invoke(index);
			}
		}

		/// <summary>
		/// Deselect specified indices without raising corresponding events (OnDeselect, etc).
		/// </summary>
		/// <param name="indices">Indices.</param>
		protected virtual void SilentDeselect(List<int> indices)
		{
			if (indices == null)
			{
				return;
			}

			foreach (var index in indices)
			{
				selectedIndices.Remove(index);
				OnDeselectInternal.Invoke(index);
			}

			selectedIndex = (selectedIndices.Count > 0) ? selectedIndices.Last() : -1;
		}

		/// <summary>
		/// Select specified indices without raising corresponding events (OnSelect, etc).
		/// </summary>
		/// <param name="indices">Indices.</param>
		protected virtual void SilentSelect(List<int> indices)
		{
			if (indices == null)
			{
				return;
			}

			foreach (var index in indices)
			{
				selectedIndices.Add(index);
				OnSelectInternal.Invoke(index);
			}

			selectedIndex = (selectedIndices.Count > 0) ? selectedIndices.Last() : -1;
		}

		/// <summary>
		/// Deselect item by the specified index.
		/// </summary>
		/// <param name="index">Index.</param>
		public void Deselect(int index)
		{
			Deselect(index, true);
		}

		/// <summary>
		/// Deselect all items.
		/// </summary>
		/// <param name="raiseEvents">Raise select events?</param>
		public void DeselectAll(bool raiseEvents = true)
		{
			GetSelectedIndices(tempSelect);

			foreach (var index in tempSelect)
			{
				Deselect(index, raiseEvents);
			}

			tempSelect.Clear();
		}

		/// <summary>
		/// Deselect item by the specified index.
		/// </summary>
		/// <param name="index">Index.</param>
		/// <param name="raiseEvents">Raise select events?</param>
		public void Deselect(int index, bool raiseEvents)
		{
			if (index < 0)
			{
				return;
			}

			if (!IsSelected(index))
			{
				return;
			}

			if (!CanBeDeselected(index))
			{
				return;
			}

			selectedIndices.Remove(index);
			selectedIndex = (selectedIndices.Count > 0) ? selectedIndices.Last() : -1;

			if (IsValid(index))
			{
				DeselectItem(index);

				InvokeDeselect(index, raiseEvents);
			}
		}

		/// <summary>
		/// Deselect removed indices.
		/// </summary>
		/// <param name="oldIndices">Previously selected indices.</param>
		/// <param name="newIndices">New selected indices.</param>
		protected virtual void DeselectRemoved(List<int> oldIndices, List<int> newIndices)
		{
			foreach (var old_index in oldIndices)
			{
				if (!newIndices.Contains(old_index))
				{
					selectedIndices.Remove(old_index);
					selectedIndex = (selectedIndices.Count > 0) ? selectedIndices.Last() : -1;
					InvokeDeselect(old_index, true);
				}
			}

			SilentDeselect(oldIndices);
		}

		/// <summary>
		/// Determines if item is selected with the specified index.
		/// </summary>
		/// <returns><c>true</c> if item is selected with the specified index; otherwise, <c>false</c>.</returns>
		/// <param name="index">Index.</param>
		public virtual bool IsSelected(int index)
		{
			return selectedIndices.Contains(index);
		}

		/// <summary>
		/// Toggle item by the specified index.
		/// </summary>
		/// <param name="index">Index.</param>
		public void Toggle(int index)
		{
			if (IsSelected(index) && MultipleSelect)
			{
				Deselect(index);
			}
			else
			{
				Select(index);
			}
		}

		/// <summary>
		/// Toggle the specified index.
		/// </summary>
		/// <param name="index">Index.</param>
		public virtual void ItemToggle(int index)
		{
			var shift_pressed = CompatibilityInput.IsShiftPressed;
			var have_selected = selectedIndices.Count > 0;
			var last_selected = selectedIndex;
			if (MultipleSelect && shift_pressed && have_selected && last_selected != index)
			{
				var start_index = RangeMode == RangeSelectionMode.StartFromFirst
					? selectedIndices.First()
					: selectedIndices.Last();

				// deselect all items
				tempDeselect.AddRange(selectedIndices);
				foreach (var i in tempDeselect)
				{
					Deselect(i);
				}
				tempDeselect.Clear();

				// find min and max indices
				var min = Mathf.Min(start_index, index);
				var max = Mathf.Max(start_index, index);

				// select items from min to max
				for (int i = min; i < max + 1; i++)
				{
					Select(i);
				}
			}
			else
			{
				Toggle(index);
			}

			if (!IsSelected(index))
			{
				var item = GetInstance(index);
				if (item != null)
				{
					HighlightColoring(item);
				}
			}
		}

		/// <summary>
		/// Move the component transform to the end of the local transform list.
		/// </summary>
		/// <param name="item">Item.</param>
		protected static void SetComponentAsLastSibling(Component item)
		{
			item.transform.SetAsLastSibling();
		}

		/// <summary>
		/// Called when item selected.
		/// Use it for change visible style of selected item.
		/// </summary>
		/// <param name="index">Index.</param>
		protected virtual void SelectItem(int index)
		{
		}

		/// <summary>
		/// Called when item deselected.
		/// Use it for change visible style of deselected item.
		/// </summary>
		/// <param name="index">Index.</param>
		protected virtual void DeselectItem(int index)
		{
		}

		/// <summary>
		/// Toggle theme support.
		/// </summary>
		protected virtual void ToggleThemeSupport()
		{
		}

		/// <summary>
		/// Updates the colors.
		/// </summary>
		/// <param name="instant">Is should be instant color update?</param>
		public virtual void ComponentsColoring(bool instant = false)
		{
		}

		/// <summary>
		/// Coloring the specified component.
		/// </summary>
		/// <param name="component">Component.</param>
		protected virtual void Coloring(ListViewItem component)
		{
		}

		/// <summary>
		/// Set default colors of specified component.
		/// </summary>
		/// <param name="component">Component.</param>
		protected virtual void DefaultColoring(ListViewItem component)
		{
		}

		/// <summary>
		/// Set highlights colors of specified component.
		/// </summary>
		/// <param name="component">Component.</param>
		protected virtual void HighlightColoring(ListViewItem component)
		{
		}

		/// <summary>
		/// This function is called when the MonoBehaviour will be destroyed.
		/// </summary>
		protected override void OnDestroy()
		{
			base.OnDestroy();

			RemoveCallbacks();

			foreach (var item in instances)
			{
				Free(item);
			}
			instances.Clear();
		}

		/// <summary>
		/// Set EventSystem.current.SetSelectedGameObject with selected or first item.
		/// </summary>
		/// <returns><c>true</c>, if component was selected, <c>false</c> otherwise.</returns>
		public virtual bool SelectComponent()
		{
			if (instances.Count == 0)
			{
				return false;
			}

			var index = (SelectedIndex != -1) ? SelectedIndex : 0;
			SelectComponentByIndex(index);

			return true;
		}

		/// <summary>
		/// Selects the component by index.
		/// </summary>
		/// <param name="index">Index.</param>
		public void SelectComponentByIndex(int index)
		{
			if (!IsValid(index))
			{
				return;
			}

			ScrollTo(index);

			var instance = GetInstance(index);
			SetSelectedGameObject(instance);
		}

		/// <summary>
		/// Set selected gameobject.
		/// </summary>
		/// <param name="instance">Instance.</param>
		protected virtual void SetSelectedGameObject(ListViewItem instance)
		{
			if (instance == null)
			{
				return;
			}

			SetSelectedGameObject(instance.gameObject);
		}

		/// <summary>
		/// Set selected gameobject.
		/// </summary>
		/// <param name="go">Game object.</param>
		protected virtual void SetSelectedGameObject(GameObject go)
		{
			if (go == null)
			{
				return;
			}

			if (EventSystem.current.alreadySelecting)
			{
				return;
			}

			if (EventSystem.current.currentSelectedGameObject != go)
			{
				EventSystem.current.SetSelectedGameObject(go);
			}
		}

		/// <summary>
		/// Navigate to the specified target.
		/// </summary>
		/// <param name="eventData">Event data.</param>
		/// <param name="target">Target.</param>
		protected virtual void Navigate(AxisEventData eventData, Selectable target)
		{
			if (target != null && target.IsActive())
			{
				eventData.selectedObject = target.gameObject;
			}
		}

		/// <summary>
		/// Navigate to the item with specified index.
		/// </summary>
		/// <param name="eventData">Event data.</param>
		/// <param name="index">Index.</param>
		/// <returns>true if navigation successful; otherwise false.</returns>
		protected virtual bool Navigate(AxisEventData eventData, int index)
		{
			if (!IsValid(index))
			{
				return false;
			}

			ScrollTo(index);

			var component = GetInstance(index);
			if (component == null)
			{
				return false;
			}

			eventData.Use();
			eventData.selectedObject = component.gameObject;

			OnNavigate.Invoke(index, component);

			return true;
		}

		/// <summary>
		/// Selects the component by index.
		/// </summary>
		/// <param name="eventData">Event data.</param>
		/// <param name="index">Index.</param>
		[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters", Justification = "Reviewed.")]
		public void SelectComponentByIndex(AxisEventData eventData, int index)
		{
			Navigate(eventData, index);
		}

		/// <summary>
		/// Handle select event.
		/// </summary>
		/// <param name="eventData">Event data.</param>
		void ISelectHandler.OnSelect(BaseEventData eventData)
		{
			SelectHandlerOnSelect(eventData);
		}

		/// <summary>
		/// Handle select event.
		/// </summary>
		/// <param name="eventData">Event data.</param>
		protected virtual void SelectHandlerOnSelect(BaseEventData eventData)
		{
			if (GetComponent<Selectable>() != null)
			{
				SetSelectedGameObject(gameObject);
			}

			OnFocusIn.Invoke(eventData);
		}

		/// <summary>
		/// Handle deselect event.
		/// </summary>
		/// <param name="eventData">Current event data.</param>
		void IDeselectHandler.OnDeselect(BaseEventData eventData)
		{
			DeselectHandlerOnDeselect(eventData);
		}

		/// <summary>
		/// Handle deselect event.
		/// </summary>
		/// <param name="eventData">Current event data.</param>
		protected virtual void DeselectHandlerOnDeselect(BaseEventData eventData)
		{
			OnFocusOut.Invoke(eventData);
		}

		/// <summary>
		/// Handle submit event.
		/// </summary>
		/// <param name="eventData">Event data.</param>
		void ISubmitHandler.OnSubmit(BaseEventData eventData)
		{
			SubmitHandlerOnSubmit(eventData);
		}

		/// <summary>
		/// Handle submit event.
		/// </summary>
		/// <param name="eventData">Event data.</param>
		protected virtual void SubmitHandlerOnSubmit(BaseEventData eventData)
		{
			SelectComponent();
			onSubmit.Invoke();
		}

		/// <summary>
		/// Handle cancel event.
		/// </summary>
		/// <param name="eventData">Event data.</param>
		void ICancelHandler.OnCancel(BaseEventData eventData)
		{
			CancelHandlerOnCancel(eventData);
		}

		/// <summary>
		/// Handle cancel event.
		/// </summary>
		/// <param name="eventData">Event data.</param>
		protected virtual void CancelHandlerOnCancel(BaseEventData eventData)
		{
			onCancel.Invoke();
		}

		/// <summary>
		/// Calls specified function with each component.
		/// </summary>
		/// <param name="func">Function to apply for each component.</param>
		public virtual void ForEachComponent(Action<ListViewItem> func)
		{
			foreach (var item in instances)
			{
				func(item);
			}
		}

		/// <summary>
		/// Calls specified function with each component.
		/// </summary>
		/// <param name="func">Function to apply for each component.</param>
		/// <typeparam name="T">Actual type of components.</typeparam>
		protected virtual void ForEachComponent<T>(Action<T> func)
			where T : ListViewItem
		{
			for (int i = 0; i < instances.Count; i++)
			{
				func(instances[i] as T);
			}
		}

		/// <summary>
		/// Set table header sizes.
		/// </summary>
		/// <param name="sizes">Column or rows sizes (columns if Horizontal direction, rows otherwise).</param>
		/// <param name="withHeader">With header.</param>
		public virtual void SetTableSizes(IList<float> sizes, bool withHeader = true)
		{
			throw new NotSupportedException();
		}

		#region DebugInfo

		/// <summary>
		/// Print debug information to console log.
		/// </summary>
		public void PrintDebugInfo()
		{
			Debug.Log(GetDebugInfo(), this);
		}

		/// <summary>
		/// Get debug information.
		/// </summary>
		/// <returns>Debug information.</returns>
		public virtual string GetDebugInfo()
		{
			throw new NotSupportedException();
		}
		#endregion

		#region ListViewPaginator support

		/// <summary>
		/// Gets the ScrollRect.
		/// </summary>
		/// <returns>The ScrollRect.</returns>
		public virtual ScrollRect GetScrollRect()
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Gets the items count.
		/// </summary>
		/// <returns>The items count.</returns>
		public virtual int GetItemsCount()
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Gets the items per block count.
		/// </summary>
		/// <returns>The items per block.</returns>
		public virtual int GetItemsPerBlock()
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Gets the item position by index.
		/// </summary>
		/// <returns>The item position.</returns>
		/// <param name="index">Index.</param>
		public virtual float GetItemPosition(int index)
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Gets the item position by index.
		/// </summary>
		/// <returns>The item position.</returns>
		/// <param name="index">Index.</param>
		public virtual float GetItemPositionBorderEnd(int index)
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Gets the item middle position by index.
		/// </summary>
		/// <returns>The item middle position.</returns>
		/// <param name="index">Index.</param>
		public virtual float GetItemPositionMiddle(int index)
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Gets the item bottom position by index.
		/// </summary>
		/// <returns>The item bottom position.</returns>
		/// <param name="index">Index.</param>
		public virtual float GetItemPositionBottom(int index)
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Gets the index of the nearest item.
		/// </summary>
		/// <returns>The nearest item index.</returns>
		public virtual int GetNearestItemIndex()
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Gets the size of the DefaultItem.
		/// </summary>
		/// <returns>Size.</returns>
		public virtual Vector2 GetDefaultItemSize()
		{
			throw new NotSupportedException();
		}

		#endregion

		#region functions to override in ListViewCustom

		/// <summary>
		/// Determines whether is sort enabled.
		/// </summary>
		/// <returns><c>true</c> if is sort enabled; otherwise, <c>false</c>.</returns>
		public virtual bool IsSortEnabled()
		{
			return false;
		}

		/// <summary>
		/// Gets the index of the nearest item.
		/// </summary>
		/// <returns>The nearest index.</returns>
		/// <param name="eventData">Event data.</param>
		public int GetNearestIndex(PointerEventData eventData)
		{
			if (IsSortEnabled())
			{
				return -1;
			}

			return GetNearestIndex(eventData, NearestType.Auto);
		}

		/// <summary>
		/// Gets the index of the nearest item.
		/// </summary>
		/// <returns>The nearest index.</returns>
		/// <param name="eventData">Event data.</param>
		/// <param name="type">Preferable nearest index.</param>
		public virtual int GetNearestIndex(PointerEventData eventData, NearestType type)
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Gets the index of the nearest item.
		/// </summary>
		/// <returns>The nearest item index.</returns>
		/// <param name="point">Point.</param>
		public int GetNearestIndex(Vector2 point)
		{
			return GetNearestIndex(point, NearestType.Auto);
		}

		/// <summary>
		/// Gets the index of the nearest item.
		/// </summary>
		/// <returns>The nearest item index.</returns>
		/// <param name="point">Point.</param>
		/// <param name="type">Preferable nearest index.</param>
		public virtual int GetNearestIndex(Vector2 point, NearestType type)
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Get scroll position.
		/// </summary>
		/// <returns>Position.</returns>
		public virtual float GetScrollPosition()
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Scrolls to specified position.
		/// </summary>
		/// <param name="position">Position.</param>
		public virtual void ScrollToPosition(float position)
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Scrolls to specified position.
		/// </summary>
		/// <param name="position">Position.</param>
		public virtual void ScrollToPosition(Vector2 position)
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Scroll to specified index with time.
		/// </summary>
		/// <param name="index">Index.</param>
		public virtual void ScrollToAnimated(int index)
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Scroll to specified index with time.
		/// </summary>
		/// <param name="index">Index.</param>
		/// <param name="animation">Animation curve.</param>
		/// <param name="unscaledTime">Unscaled time.</param>
		/// <param name="after">Action to run after animation.</param>
		public virtual void ScrollToAnimated(int index, AnimationCurve animation, bool unscaledTime, Action after = null)
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Scrolls to specified position with time.
		/// </summary>
		/// <param name="target">Position.</param>
		public virtual void ScrollToPositionAnimated(float target)
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Scrolls to specified position with time.
		/// </summary>
		/// <param name="target">Position.</param>
		/// <param name="after">Action to run after animation.</param>
		/// <param name="everyFrame">Action to run every frame.</param>
		public virtual void ScrollToPositionAnimated(float target, Action after, Action everyFrame)
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Scrolls to specified position with time.
		/// </summary>
		/// <param name="target">Position.</param>
		/// <param name="animation">Animation curve.</param>
		/// <param name="unscaledTime">Unscaled time.</param>
		/// <param name="after">Action to run after animation.</param>
		/// <param name="everyFrame">Action to run every frame.</param>
		public virtual void ScrollToPositionAnimated(float target, AnimationCurve animation, bool unscaledTime, Action after = null, Action everyFrame = null)
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Scrolls to specified position with time.
		/// </summary>
		/// <param name="target">Position.</param>
		public virtual void ScrollToPositionAnimated(Vector2 target)
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Scrolls to specified position with time.
		/// </summary>
		/// <param name="target">Position.</param>
		/// <param name="animation">Animation curve.</param>
		/// <param name="unscaledTime">Unscaled time.</param>
		/// <param name="after">Action to run after animation.</param>
		public virtual void ScrollToPositionAnimated(Vector2 target, AnimationCurve animation, bool unscaledTime, Action after = null)
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Stop scrolling.
		/// </summary>
		public virtual void ScrollStop()
		{
			throw new NotSupportedException();
		}

		#endregion

		#region Interactable

		[SerializeField]
		Color disabledColor = new Color32(200, 200, 200, 128);

		/// <summary>
		/// Gets or sets the disabled color when widget not interactable.
		/// </summary>
		/// <value>The color of the disabled.</value>
		public Color DisabledColor
		{
			get
			{
				return disabledColor;
			}

			set
			{
				if (disabledColor != value)
				{
					disabledColor = value;
					InteractableChanged();
				}
			}
		}

		[SerializeField]
		bool interactable = true;

		/// <summary>
		/// Is widget interactable.
		/// </summary>
		/// <value><c>true</c> if interactable; otherwise, <c>false</c>.</value>
		public bool Interactable
		{
			get
			{
				return interactable;
			}

			set
			{
				if (interactable != value)
				{
					interactable = value;
					InteractableChanged();
				}
			}
		}

		/// <summary>
		/// If the canvas groups allow interaction.
		/// </summary>
		protected bool GroupsAllowInteraction = true;

		/// <summary>
		/// The CanvasGroup cache.
		/// </summary>
		protected readonly List<CanvasGroup> CanvasGroupCache = new List<CanvasGroup>();

		/// <summary>
		/// Process the CanvasGroupChanged event.
		/// </summary>
		protected override void OnCanvasGroupChanged()
		{
			var groupAllowInteraction = true;
			var t = transform;
			while (t != null)
			{
				t.GetComponents(CanvasGroupCache);
				var shouldBreak = false;
				foreach (var canvas_group in CanvasGroupCache)
				{
					if (!canvas_group.interactable)
					{
						groupAllowInteraction = false;
						shouldBreak = true;
					}

					shouldBreak |= canvas_group.ignoreParentGroups;
				}

				if (shouldBreak)
				{
					break;
				}

				t = t.parent;
			}

			if (groupAllowInteraction != GroupsAllowInteraction)
			{
				GroupsAllowInteraction = groupAllowInteraction;
				InteractableChanged();
			}
		}

		/// <summary>
		/// Determines whether this widget is interactable.
		/// </summary>
		/// <returns><c>true</c> if this instance is interactable; otherwise, <c>false</c>.</returns>
		public virtual bool IsInteractable()
		{
			return GroupsAllowInteraction && Interactable;
		}

		/// <summary>
		/// Process interactable change.
		/// </summary>
		protected virtual void InteractableChanged()
		{
			ComponentsColoring(true);

			if (IsInteractable())
			{
				OnInteractableEnabled();
			}
			else
			{
				OnInteractableDisabled();
			}
		}

		/// <summary>
		/// What to do when widget became interactable.
		/// </summary>
		protected virtual void OnInteractableEnabled()
		{
		}

		/// <summary>
		/// What to do when widget became not interactable.
		/// </summary>
		protected virtual void OnInteractableDisabled()
		{
		}
		#endregion

		#region IStylable implementation

		/// <inheritdoc/>
		public virtual bool SetStyle(Style style)
		{
			return false;
		}

		/// <inheritdoc/>
		public virtual bool GetStyle(Style style)
		{
			return false;
		}
		#endregion

		/// <summary>
		/// Upgrade serialized data to the latest version.
		/// </summary>
		public virtual void Upgrade()
		{
		}
	}
}